\chapter{Development and Implementation}
\section{The Linux Kernel}
The Linux kernel is a monolithic Unix-like computer operating system kernel. The Linux operating system is based on it and deployed on both traditional computer systems such as personal computers, servers and small system on chip computers; usually in the form of Linux distributions, and on various embedded devices such as routers, wireless access points, PBXes, set-top boxes, FTA receivers, smart TVs, PVRs and NAS appliances. The Android operating system for tablet computers, smartphones and smart-watches is also based atop the Linux kernel.\\
The Linux kernel was conceived and created in 1991 by Linux Torvalds for his personal computer and with no cross-platform intentions, but has since expanded to support to huge array of computer architecture, many more than other operating systems or kernels. Linux rapidly attracted developers and users who adopted it as the kernel for other free software projects, notably the GNU Operating System. The Linux kernel has received contributions from nearly 12,000 programmers from more than 1,200 companies, including some of the largest software and hardware vendors.
\subsection{The Linux Device Driver Model}
Linux today supports more hardware devices than any other operating system in the history of the world. It does this using a development model significantly different from the familiar Windows device driver model. The Linux development process continues to evolve to better support the needs of Independent Hardware Vendors (IHVs), distributions, and other members of the community, and the advantages of the Linux model are increasing with time. While Linux will not provide a stable source or binary interface for driver developers, IHVs should familiarize themselves with a number of useful projects, many sponsored by the Linux Foundation, that ease driver development, including the Hardware NDA program, the Linux Drivers Project, and the Driver Backport Workgroup. When IHVs engage with the Linux community, they almost invariably find that the Linux driver model provides significant benefits that lower their costs while producing better drivers.
\subsubsection{Overview}
A fundamental purpose for operating systems (OSes) is to serve as an abstraction layer between applications and hardware to enable interoperability. An IHV wants their hardware to be able to make use of all the relevant features of an OS, and an OS wants to take full advantage of the hardware it's running on. Since both the OS and the hardware tend to add and to rearrange features over time, it is a dynamic interaction. What everybody wants is for the hardware to “Just Work” without hassles or support calls.\\
Today, Linux works with more devices than any other OS in the history of the world.
\subsubsection{Driver Model}
The Linux driver model is different. For users, the goal is to provide the “Just Works” experience. The Linux model is that IHVs get the source code for their driver accepted into the mainline kernel. This entails a public peer review process to ensure that the driver code is of sufficient quality and does not have obvious bugs or security risks. Linux has neither a stable binary driver ABI nor a stable source-code driver Application Programming Interface (API). That is, there is no guarantee that an interface provided in one version of the kernel will be available in the next version, and portions of the ABI and API change in every kernel release.\\
By contrast, the Linux kernel does provide a stable user-space interface for Linux applications. These applications essentially have a contract with the Linux kernel that the user-space binary interfaces they rely on will continue to work consistently over time. That's why a pre-compiled Linux application can run correctly on multiple distributions and multiple versions. The underlying implementation of the user-space binary interfaces can and does change, but even an application compiled for pre-1.0 Linux will run correctly on the latest kernel. This is the opposite of device drivers, which have no guarantee whatsoever that any interface they rely on, whether binary or source, will remain consistent between versions of the kernel.\\
Counterintuitive though it might be from a proprietary viewpoint, this lack of internal kernel interface stability is preferable because both the kernel code and all of the drivers relying on it are open source. In fact, driver code is an integral part of the Linux operating system, not a second-class add-on. Once a driver is accepted into the mainline kernel, it will be maintained over time as internal kernel interfaces change. That is, when a subsystem maintainer accepts a patch to make an incompatible change to a kernel interface, that patch will simultaneously upgrade every driver that relies on the interface. And, new drivers and any upgrades to them automatically flow downstream from the mainline kernel to all Linux distributions.\\
The key strength of this approach from the user's viewpoint is that, in happy contrast with proprietary operating systems like Windows Vista, once a device is working on a given version of Linux, that support continues through all future versions. (Devices are generally only removed when they have become so rare that no users can be found.) In Linux, hardware support only gets better; it never gets worse.\\
From the IHV's point of view, the big benefit is that an IHV's driver is maintained over time by the community, meaning that other people fix, tune, and add features to the driver. When internal kernel interfaces change in each new OS release, IHVs don't need to write and release a new driver; their driver is upgraded automatically. Obsolete interfaces can be deprecated and removed rather than being maintained indefinitely. Common subsystems can be factored out of drivers, enabling leaner, less buggy device drivers while adding more functionality for all hardware. This improves the stability, security, and maturity of both the OS and the driver.\\
In addition, the Linux model enables cross-architecture driver support nearly for free. Even when an IHV only tests their driver on one chip architecture, interested developers ensure that the driver works with every architecture that Linux supports, which is more than any other OS in history. The strength of this approach has been especially apparent over the last decade as many chip architectures have moved from the 32 to 64 bits. Nearly all Linux drivers were quickly updated to support these newer architectures, while driver support for 64-bit Windows Vista even on the highest volume x86 architecture remains extremely poor today.\\
The biggest hurdle of the Linux driver model for some IHVs is the need to open source their driver code, which a small (but thankfully dwindling) number have been reluctant to do. Also, once a driver is accepted into the mainline, it can take up to 18 months to be deployed into an enterprise distro. It has not until now been convenient to backport the driver to existing distros, but that is improving with the Driver Backport Workgroup.\\
Having hardware reliably supported by Linux means getting the driver accepted into the mainline kernel. Supporting an out-of-mainline open source driver creates significant, never-ending support costs for the IHV, as new versions constantly need to be released as the kernel API changes. Supporting an out-of-mainline binary driver means even bigger, never-ending support costs for the IHV, and directly contradicts the recent statement by a large number of kernel developers that binary drivers are “undesirable”.\\
The Linux driver model is different from the Windows model many IHVs are used to. But it is a consistent and compelling approach, and has been successful at supporting nearly the entire universe of computer hardware. Moreover, the vast majority of all IHVs have adapted to Linux and have thriving businesses that work with the Linux driver development model.
\subsection{Overview of SPI support in Linux}
\subsubsection{What is SPI?}
The ``Serial Peripheral Interface'' (SPI) is a synchronous four wire serial link used to connect microcontrollers to sensors, memory, and peripherals. It's a simple ``de facto'' standard, not complicated enough to acquire a standardization body.  SPI uses a master/slave configuration.\\
The three signal wires hold a clock (SCK, often on the order of 10 MHz), and parallel data lines with ``Master Out, Slave In'' (MOSI) or ``Master In, Slave Out'' (MISO) signals.  (Other names are also used.)  There are four clocking modes through which data is exchanged; mode-0 and mode-3 are most commonly used.  Each clock cycle shifts data out and data in; the clock doesn't cycle except when there is a data bit to shift.  Not all data bits are used though; not every protocol uses those full duplex capabilities.\\
SPI masters use a fourth ``chip select'' line to activate a given SPI slave device, so those three signal wires may be connected to several chips in parallel.  All SPI slaves support chipselects; they are usually active low signals, labeled nCSx for slave 'x' (e.g. nCS0).  Some devices have other signals, often including an interrupt to the master. \\
Unlike serial busses like USB or SMBus, even low level protocols for SPI slave functions are usually not interoperable between vendors (except for commodities like SPI memory chips).
\begin{itemize}
	\item SPI may be used for request/response style device protocols, as with touchscreen sensors and memory chips.
	\item It may also be used to stream data in either direction (half duplex), or both of them at the same time (full duplex).
	\item Some devices may use eight bit words.  Others may use different word     lengths, such as streams of 12-bit or 20-bit digital samples.
	\item Words are usually sent with their most significant bit (MSB) first, but sometimes the least significant bit (LSB) goes first instead.
	\item Sometimes SPI is used to daisy-chain devices, like shift registers.
\end{itemize}
In the same way, SPI slaves will only rarely support any kind of automatic discovery/enumeration protocol.  The tree of slave devices accessible from a given SPI master will normally be set up manually, with configuration tables.\\
SPI is only one of the names used by such four-wire protocols, and most controllers have no problem handling ``MicroWire'' (think of it as half-duplex SPI, for request/response protocols), SSP (``Synchronous Serial Protocol''), PSP (``Programmable Serial Protocol''), and other related protocols.\\
Some chips eliminate a signal line by combining MOSI and MISO, and limiting themselves to half-duplex at the hardware level. In fact some SPI chips have this signal mode as a strapping option.  These can be accessed using the same programming interface as SPI, but of course they won't handle full duplex transfers.  You may find such chips described as using ``three wire'' signaling: SCK, data, nCSx. (That data line is sometimes called MOMI or SISO.) \\
Microcontrollers often support both master and slave sides of the SPI protocol.  This document (and Linux) currently only supports the master side of SPI interactions.
\subsubsection{Who uses SPI?}
Linux developers using SPI are probably writing device drivers for embedded systems boards.  SPI is used to control external chips, and it is also a protocol supported by every MMC or SD memory card.  (The older ``DataFlash'' cards, predating MMC cards but using the same connectors and card shape, support only SPI.)  Some PC hardware uses SPI flash for BIOS code. \\
SPI slave chips range from digital/analog converters used for analog sensors and codecs, to memory, to peripherals like USB controllers or Ethernet adapters; and more. \\
Most systems using SPI will integrate a few devices on a mainboard. Some provide SPI links on expansion connectors; in cases where no dedicated SPI controller exists, GPIO pins can be used to create a low speed ``bitbanging'' adapter.  Very few systems will ``hotplug'' an SPI controller; the reasons to use SPI focus on low cost and simple operation, and if dynamic reconfiguration is important, USB will often be a more appropriate low-pincount peripheral bus. \\
Many microcontrollers that can run Linux integrate one or more I/O interfaces with SPI modes. Given SPI support, they could use MMC or SD cards without needing a special purpose MMC, SD or SDIO controller.
\subsubsection{The SPI programming interface}
The linux/spi/spi.h header file includes kerneldoc, as does the main source code, and you should certainly read that chapter of the kernel API document.  This is just an overview, so you get the big picture before those details. \\
SPI requests always go into I/O queues.  Requests for a given SPI device are always executed in FIFO order, and complete asynchronously through completion callbacks.  There are also some simple synchronous wrappers for those calls, including ones for common transaction types like writing a command and then reading its response. \\
There are two types of SPI driver, here called: \\
Controller drivers ... controllers may be built into System-On-Chip 	processors, and often support both Master and Slave roles. 	These drivers touch hardware registers and may use DMA. 	Or they can be PIO bitbangers, needing just GPIO pins.\\ 
Protocol drivers ... these pass messages through the controller 	driver to communicate with a Slave or Master device on the 	other side of an SPI link. \\
So for example one protocol driver might talk to the MTD layer to export data to filesystems stored on SPI flash like DataFlash; and others might control audio interfaces, present touchscreen sensors as input interfaces, or monitor temperature and voltage levels during industrial processing. And those might all be sharing the same controller driver.\\
A ``struct spi\_device'' encapsulates the master-side interface between those two types of driver.  At this writing, Linux has no slave side programming interface. \\
There is a minimal core of SPI programming interfaces, focussing on using the driver model to connect controller and protocol drivers using device tables provided by board specific initialization code.  SPI shows up in sysfs in several locations: 
\begin{itemize}
	\item /sys/devices/.../CTLR ... physical node for a given SPI controller 
	\item /sys/devices/.../CTLR/spiB.C... spi\_device on bus ``B'', chipselect C, accessed through CTLR. 
	\item /sys/bus/spi/devices/spiB.C ... symlink to that physical .../CTLR/spiB.C device 
	\item /sys/devices/.../CTLR/spiB.C/modalias ... identifies the driver that should be used with this device (for hotplug/coldplug) 
	\item /sys/bus/spi/drivers/D ... driver for one or more spi*.* devices 
	\item /sys/class/spi\_master/spiB ... symlink (or actual device node) to a logical node which could hold class related state for the controller managing bus ``B''. All spiB.* devices share one physical SPI bus segment, with SCLK, MOSI, and MISO. 
\end{itemize}
Note that the actual location of the controller's class state depends on whether you enabled CONFIG\_SYSFS\_DEPRECATED or not.  At this time, the only class-specific state is the bus number (``B'' in ``spiB''), so those /sys/class entries are only useful to quickly identify busses.
\section{The C Programming Language}
C is the language of the Linux kernel. Almost all of the kernel and related applications are written in C. C is of course the language of development in this project.\\
C is a general-purpose programming language with features economy of expression, modern flow control and data structures, and a rich set of operators. C is not a ``very high level'', language, nor a big one, and is not specialized to any particular area of application. But its absence of restrictions and its generality make it more convenient and effective for many tasks than supposedly more powerful languages. C was originally designed for and implemented on the UNIX operating system on the DEC PDP-11, by Dennis Ritchie. The operating system, the C compiler, and essentially all UNIX applications programs (including all of the software used to prepare this book) are written in C. Production compilers also exist for several other machines, including the IBM System/370, the Honeywell 6000, and the Interdata 8/32. C is not tied to any particular hardware or system, however, and it is easy to write programs that will run without change on any machine that supports C.\\
The C language has a very simple structure and hence is much easily converted into machine code without any overhead that may be faced when using other languages. That is why almost all of the kernel development and device drivers are done in C language only even after the introduction of so many other versatile languages like C++.
\section{Development Boards}
In order to develop and test the driver code as well as to interface the SPIRIT1 chip to the host via SPI, there was need for a system-on-board computer. The host of course needed to run on a Linux kernel, so the following two were the obvious choices
\subsection{Raspberry Pi 2}
Several generations of Raspberry Pis have been released. The first generation (Raspberry Pi 1 Model B) was released in February 2012. It was followed by a simpler and inexpensive model Model A. In 2014 the foundation released a board with an improved design in Raspberry Pi 1 Model B+. The model laid the current ``mainline'' form-factor. Improved A+ and B+ models were released a year later. A cut down ``compute'' model was released in April 2014, and a Raspberry Pi Zero with smaller size and limited input/output (I/O) and general-purpose input/output (GPIO) abilities was released in November 2015 for US\$5. The Raspberry Pi 2 which added more RAM was released in February 2015. Raspberry Pi 3 Model B released in February 2016 is bundled with on-board WiFi and Bluetooth. As of 2016, Raspberry Pi 3 Model B is the newest mainline Raspberry Pi. These boards are priced between US \$20–35.\\
All models feature a Broadcom system on a chip (SoC), which includes an ARM compatible central processing unit (CPU) and an on chip graphics processing unit (GPU, a VideoCore IV). CPU speed ranges from 700 MHz to 1.2 GHz for the Pi 3 and on board memory range from 256 MB to 1 GB RAM. Secure Digital (SD) cards are used to store the operating system and program memory in either the SDHC or MicroSDHC sizes. Most boards have between one and four USB slots, HDMI and composite video output, and a 3.5 mm phone jack for audio. Lower level output is provided by a number of GPIO pins which support common protocols like I²C. The B-models have an 8P8C Ethernet port and the Pi 3 has on board Wi-Fi 802.11n and Bluetooth.\\
The Foundation provides Raspbian, a Debian-based Linux distribution for download, as well as third party Ubuntu, Windows 10 IOT Core, RISC OS, and specialised media center distributions. It promotes Python and Scratch as the main programming language, with support for many other languages. The default firmware is closed source, while an unofficial open source is available.
The Raspberry Pi 3 model was used for preliminary development of this driver.
\begin{figure}[H]
	\centering
	\includegraphics[width=4.0in, height=3.2in]{images/raspberry_pi.png}
	\caption{Raspberry Pi 2}
\end{figure}
\subsection{BeagleBone Black}
The BeagleBoard is a low-power open-source hardware single-board computer produced by Texas Instruments in association with Digi-Key and Newark element14. The BeagleBoard was also designed with open source software development in mind, and as a way of demonstrating the Texas Instrument's OMAP3530 system-on-a-chip. The board was developed by a small team of engineers as an educational board that could be used in colleges around the world to teach open source hardware and software capabilities. It is also sold to the public under the Creative Commons share-alike license. The board was designed using Cadence OrCAD for schematics and Cadence Allegro for PCB manufacturing; no simulation software was used.\\
The BeagleBone Black is the newest member of the BeagleBoard family. It is a lower-cost, high-expansion focused BeagleBoard using a low cost Sitara XAM3359AZCZ100 Cortex A8 ARM processor from Texas Instruments. It is similar to the Beaglebone,but with some features removed and some features added. The table below gives the high points on the differences between the BeagleBone and BeagleBone Black.
\begin{figure}[ht]
	\centering
	\includegraphics[width=3.5in, height=3in]{images/beaglebone_black.png}
	\caption{BeagleBone Black}
\end{figure}
\section{Tools used}
\subsection{Buildroot}
Buildroot is a set of Makefiles and patches that simplifies and automates the process of building a complete and bootable Linux environment for an embedded system, while using cross-compilation to allow building for multiple target platforms on a single Linux-based development system. Buildroot can automatically build the required cross-compilation toolchain, create a root file system, compile a Linux kernel image, and generate a boot loader for the targeted embedded system, or it can perform any independent combination of these steps. For example, an already installed cross-compilation toolchain can be used independently, while Buildroot only creates the root file system. \\
Buildroot is primarily intended to be used with small or embedded systems based on various computer architectures and instruction set architectures (ISAs), including x86, ARM, MIPS and PowerPC. Numerous architectures and their variants are supported; Buildroot also comes with default configurations for several off-the-shelf available embedded boards, such as Cubieboard, Raspberry Pi and SheevaPlug. Several third-party projects and products use Buildroot as the basis for their build systems, including the OpenWrt project that creates an embedded operating system, and firmware for the customer-premises equipment (CPE) used by the Google Fiber broadband service.\\
Multiple C standard libraries are supported as part of the toolchain, including the GNU C Library, uClibc and musl, as well as the C standard libraries that belong to various preconfigured development environments, such as those provided by Linaro. Buildroot's build configuration system internally uses Kconfig, which provides features such as a menu-driven interface, handling of dependencies, and contextual help; Kconfig is also used by the Linux kernel for its source-level configuration. Buildroot is organized around numerous automatically downloaded packages, which contain the source code of various userspace applications, system utilities, and libraries. Root file system images, which are the final results, may be built using various file systems, including cramfs, JFFS2, romfs, SquashFS and UBIFS.\\
Buildroot is free and open-source software, maintained by Peter Korsgaard and licensed under version 2 or later of the GNU General Public License (GPL). The project started in 2001, with initial intentions to serve as a testbed for uClibc. New releases are made available every three months.
\begin{figure}[ht]
	\centering
	\includegraphics[width=3.5in, height=3in]{images/buildroot.png}
	\caption{Buildroot}
\end{figure}
\subsection{Cscope}
While hacking around the Linux source code it becomes very difficult to keep track of the program flow or the variable structures in your head. There isn’t any IDE to help out in source code browsing either. In such situation a tool is necessary that browses source code and is based on the terminal. This is where cscope comes into picture.\\
cscope is a programming tool which works in console mode, text-based interface, that allows computer programmers or software developers to search source code of the programming language C, with some support for C++ and Java. It is often used on very large projects to find source code, functions, declarations, definitions and regular expressions given a text string. cscope is free and released under a BSD license. The original developer of cscope is \textbf{Joe Steffen}.\\
The history of the tool goes back to the days of the PDP-11, but it is still used by developers who are accustomed to using the vi or Vim editor or other text-based editors, instead of editors based on graphical user interfaces (GUI)s. The functions in cscope are available to varying degrees in modern graphical source editors.
cscope is used in two phases. First a developer builds the cscope database. The developer can often use find or other Unix tools to get the list of filenames needed to index into a file called cscope.files. The developer then builds a database using the command cscope -b -q -k. The k flag is intended to build a database for an operating system or C library source code. It will not look in /usr/include. Second, the developer can now search those files using the command cscope -d. Often an index must be rebuilt whenever changes are made to files.\\
In software development it is often very useful to be able to find the callers of a function because this is the way to understand how code works and what other parts of the program expect from a function. cscope can find the callers and callees of functions, but it is not a compiler and it does that by searching the text for keywords. This has the disadvantages that macros and duplicate symbol names can generate an unclear graph. There are other programs that can extract this information by parsing the source code or looking at the generated object files.
cscope was created to search content within C files, but it can also be used (with some limits) for C++ and Java files.
\begin{figure}[ht]
	\centering
	\includegraphics[scale=0.8]{images/cscope.png}
	\caption{Source Browsing through Cscope}
\end{figure}
\subsection{VIM}
Vim (a contraction of Vi IMproved) is a clone of Bill Joy's vi text editor program for Unix. It was written by Bram Moolenaar based on source for a port of the Stevie editor to the Amiga and first released publicly in 1991. Vim is designed for use both from a command-line interface and as a standalone application in a graphical user interface. Vim is free and open source software and is released under a license that includes some charityware clauses, encouraging users who enjoy the software to consider donating to children in Uganda. The license is compatible with the GNU General Public License. Although Vim was originally released for the Amiga, Vim has since been developed to be cross-platform, supporting many other platforms. In 2006, it was voted the most popular editor amongst Linux Journal readers; in 2015 the Stack Overflow developer survey found it to be the third most popular text editor; and in 2016 the Stack Overflow developer survey found it to be the fourth most popular development environment. Although there are many editor available such as Nano. In Vim we have two modes Insert mode and command mode. Insert mode is started by pressing the I and then we insert the words whereas command mode is start by pressing the Esc key.\\
Some basic commands are :
\begin{itemize}
	\item Moving through the text is usually possible with the arrow keys, but in the command mode try:
	\item h to move the cursor to the left
	\item l to move it to the right
	\item k to move up
	\item j to move down
	\item SHIFT-G will put the prompt at the end of the document.
\end{itemize}
\subsection{Logic Analyzer}
A logic analyzer is an electronic instrument that captures and displays multiple signals from a digital system or digital circuit. A logic analyzer may convert the captured data into timing diagrams, protocol decodes, state machine traces, assembly language, or may correlate assembly with source-level software. Logic Analyzers have advanced triggering capabilities, and are useful when a user needs to see the timing relationships between many signals in a digital system.\\
\begin{figure}[ht]
	\centering
	\includegraphics[scale=0.45]{images/logic_analyzer.png}
	\caption{Logic Analyzer}
\end{figure}
\subsection{Programming interface}
\subsubsection{Makefile for SPIRIT1}
To compile the code of the SPIRIT1 as a module we need the Makefile which we already discussed in the previous section. Now we will see the format of the Makefile:\\
MODULES := spi.o\\
ARCH := arm\\
CROSS\_COMPILE :=/home/zinga/Ravi/oldrasberry/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian/bin/arm-linux-gnueabihf-\\
obj-m := \$(MODULES)
OUTDIR := /home/zinga/Ravi/oldrasberry/linux \\
MAKEARCH := \$(MAKE) ARCH=\$(ARCH) CROSS\_COMPILE=\$(CROSS\_COMPILE) \\
all: modules\\
modules:\\
\$(MAKEARCH) -C \$(OUTDIR) M=\$\lbrace shell pwd\rbrace modules\\
clean:\\
\$(MAKEARCH) -C \$(OUTDIR) M=\$\lbrace shell pwd\rbrace clean



\subsubsection{Linux Kernel SPI support for SPIRIT1}
The ``Serial Peripheral Interface'' (SPI) is a synchronous four wire serial link used to connect microcontrollers to sensors, memory, and peripherals.
It's a simple ``de facto'' standard, not complicated enough to acquire a standardization body.  SPI uses a master/slave configuration. The three signal wires hold a clock (SCK, often on the order of 10 MHz), and parallel data lines with ``Master Out, Slave In'' (MOSI) or ``Master In, Slave Out'' (MISO) signals.  (Other names are also used.)  There are four clocking modes through which data is exchanged; mode-0 and mode-3 are most commonly used.  Each clock cycle shifts data out and data in; the clock doesn't cycle except when there is a data bit to shift.  Not all data bits are used though; not every protocol uses those full duplex capabilities.\\

SPI masters use a fourth ``chip select'' line to activate a given SPI slave device, so those three signal wires may be connected to several chips
in parallel.  All SPI slaves support chipselects; they are usually active low signals, labeled nCSx for slave 'x' (e.g. nCS0).  Some devices have
other signals, often including an interrupt to the master.\\
SPI is only one of the names used by such four-wire protocols, and most controllers have no problem handling ``MicroWire'' (think of it as half-duplex SPI, for request/response protocols), SSP (``Synchronous Serial Protocol''), PSP (``Programmable Serial Protocol''), and other related protocols.
\paragraph{Four modes in SPI}
The four modes combine two mode bits:\\
\begin{itemize}
 	\item CPOL indicates the initial clock polarity.  CPOL=0 means the clock starts low, so the first (leading) edge is rising, and the second (trailing) edge is falling.  CPOL=1 means the clock starts high, so the first (leading) edge is falling.
	  \item CPHA indicates the clock phase used to sample data; CPHA=0 says
	      sample on the leading edge, CPHA=1 means the trailing edge.
	   \item Since the signal needs to stablize before it's sampled, CPHA=0
		    implies that its data is written half a clock before the first
		       clock edge.  The chipselect may have made it become available.\\
		       Chip specs won't always say ``uses SPI mode X'' in as many words,
		       but their timing diagrams will make the CPOL and CPHA modes clear.
		       In the SPI mode number, CPOL is the high order bit and CPHA is the
		       low order bit.  So when a chip's timing diagram shows the clock
		       starting low (CPOL=0) and data stabilized for sampling during the
		       trailing clock edge (CPHA=1), that's SPI mode 1.

		       Note that the clock mode is relevant as soon as the chipselect goes
		       active.  So the master must set the clock to inactive before selecting
		       a slave, and the slave can tell the chosen polarity by sampling the
		       clock level when its select line goes active.  That's why many devices
		       support for example both modes 0 and 3:  they don't care about polarity,
		       and always clock data in/out on rising clock edges.
\end{itemize}
\paragraph{Write the SPI master controller driver}
An SPI controller will probably be registered on the platform\_bus; write a driver to bind to the device, whichever bus is involved. The main task of this type of driver is to provide an ``spi\_master''.
Use spi\_alloc\_master() to allocate the master, and spi\_master\_get\_devdata() to get the driver-private data allocated for that device.
	struct spi\_master	*master;\\
	struct CONTROLLER	*c;\\
	master = spi\_alloc\_master(dev, sizeof *c);\\
			if (!master)\\
			return -ENODEV;\\
			c = spi\_master\_get\_devdata(master);\\
The driver will initialize the fields of that spi\_master, including the bus number (maybe the same as the platform device ID) and three methods used to interact with the SPI core and SPI protocol drivers.  It will also initialize its own internal state.\\
If we need to remove your SPI controller driver, spi\_unregister\_master() will reverse the effect of spi\_register\_master().
\paragraph{SPI master methods}\\
master-$>$setup(struct spi\_device *spi)\\
This sets up the device clock rate, SPI mode, and word sizes. Drivers may change the defaults provided by board\_info, and then call spi\_setup(spi) to invoke this routine.  It may sleep.\\
Unless each SPI slave has its own configuration registers, don't change them right away ... otherwise drivers could corrupt I/O that's in progress for other SPI devices.
\begin{itemize}
	\item BUG ALERT:  for some reason the first version of
	\item many spi\_master drivers seems to get this wrong.
	\item When you code setup(), ASSUME that the controller is actively processing transfers for another device.
\end{itemize}
master-$>$cleanup(struct spi\_device *spi) \\
	Controller driver may use spi\_device.controller\_state to hold
		state it dynamically associates with that device.  If we do that,
			be sure to provide the cleanup() method to free that state.\\
\paragraph{Write the SPI protocol driver}\\
Most SPI drivers are currently kernel drivers, but there's also support for userspace drivers. Here we talk only about kernel drivers.\\
SPI protocol drivers somewhat resemble platform device drivers:\\
\begin{code}
	static struct spi\_driver CHIP\_driver = \lbrace \\
			.driver = \lbrace \\
			.name		= ``CHIP'',\\
			.owner		= THIS\_MODULE,\\
			.pm		= &CHIP\_pm\_ops,\\
		\rbrace , \\ 
			.probe		= CHIP\_probe,\\
			.remove		= CHIP\_remove,\\
		\rbrace. \\ 
\end{code}
Now compile the driver using the below command \\ make \\ and with the lsmod we are able to show the module of SPIRIT1. \\
After this we are able to see our device i.e. SPIRIT1 in the spi category. \\
cd /class/spi/ \\
\subsection{Transfer the data over SPI}
By making the entry of our device in the SPI now we have to transfer the data over the SPI. For that we have to make the read and write function for the SPI.
\begin{itemize}
	\item To read the data from SPI. \\
	int (*read) (struct stsp\_dev *dev, u8 addr, int len, u8 *data);\\
	To read the data we have to give the address of the buffer, length of the data that has to be read and the data.
	\item To write the data from SPI. \\
	int (*write) (struct stsp\_dev *dev, u8 addr, int len, char *data);\\
	To write the data over the SPI we have to follow the above function.\\
In the stsp\_dev function we have to give the device information.\\
\end{itemize}
Now to transfer the data over the the syntax is: \\
\begin{code}
static const struct stsp\_transfer\_function stsp\_spi\_tf = \lbrace \\
	.write = stsp\_spi\_write, \\
	.read = stsp\_spi\_read, \\
	\rbrace \\
\end{code}
	After this we are able to send the data over SPI. \\
\subsubsection{SYSFS programming Interface}
sysfs is a ram-based filesystem initially based on ramfs. It provides
a means to export kernel data structures, their attributes, and the 
linkages between them to userspace.\\
sysfs is always compiled in if CONFIG\_SYSFS is defined. We can access
it by doing:\\

    mount -t sysfs sysfs /sys\\
    For every kobject that is registered with the system, a directory is
    created for it in sysfs. That directory is created as a subdirectory
    of the kobject's parent, expressing internal object hierarchies to
    userspace. Top-level directories in sysfs represent the common
    ancestors of object hierarchies; i.e. the subsystems the objects
    belong to.\\
    Sysfs internally stores a pointer to the kobject that implements a
    directory in the kernfs\_node object associated with the directory. In
    the past this kobject pointer has been used by sysfs to do reference
    counting directly on the kobject whenever the file is opened or closed.
    With the current sysfs implementation the kobject reference count is
    only modified directly by the function sysfs\_schedule\_callback().
    \paragraph{Attributes}\\
    Attributes can be exported for kobjects in the form of regular files in
    the filesystem. Sysfs forwards file I/O operations to methods defined
    for the attributes, providing a means to read and write kernel
    attributes.\\Attributes should be ASCII text files, preferably with only one value
    per file. It is noted that it may not be efficient to contain only one
    value per file, so it is socially acceptable to express an array of
    values of the same type. An attribute definition is simply:\\
    \begin{code}
    struct attribute \lbrace \\ 
            char * name;\\
	    struct module *owner;\\
            umode\_t   mode;\\
			    \rbrace ;\\
    \end{code}
    int sysfs\_create\_file(struct kobject * kobj, const struct attribute * attr);\\
    void sysfs\_remove\_file(struct kobject * kobj, const struct attribute * attr);\\
    A bare attribute contains no means to read or write the value of the
    attribute.Subsystems are encouraged to define their own attribute
    structure and wrapper functions for adding and removing attributes for
    a specific object type.\\
	\begin{code}
	struct device\_attribute \lbrace \\
	struct attribute	attr;\\
		ssize\_t (*show)(struct device *dev, struct device\_attribute *attr, char *buf);\\
		ssize\_t (*store)(struct device *dev, struct device\_attribute *attr, const char *buf, size\_t count);\\
	\rbrace ; \\						

	\end{code}
	Now we have to define the device attributes. \\
	$#$define DEVICE\_ATTR(\_name, \_mode, \_show, \_store) \\
	struct device\_attribute dev\_attr\_mode\_name = \_ATTR(\_name, \_mode, \_show, \_store)\\
\subsection{Reading/writing Attribute data}
To read or write attributes, show() or store() methods must be
specified when declaring the attribute. The method types should be as
simple as those defined for device attributes:\\
ssize\_t (*show)(struct device *dev, struct device\_attribute *attr, char *buf);\\
ssize\_t (*store)(struct device *dev, struct device\_attribute *attr,
                 const char *buf, size\_t count);\\
		 IOW, they should take only an object, an attribute, and a buffer as parameters.\\
		 sysfs allocates a buffer of size (PAGE\_SIZE) and passes it to the
		 method. Sysfs will call the method exactly once for each read or
		 write.\\
		 The format of the implementation of the syfs for the SPIRIT1 is:\\
		 \begin{code}
		 static ssize\_t show\_name(struct device *dev, struct device\_attribute *attr,
		                          char *buf)\\
		\lbrace \\
		return scnprintf(buf, PAGE\_SIZE, ``\%s'', dev$->$name);\\
		\rbrace \\
		static ssize\_t store\_name(struct device *dev, struct device\_attribute *attr,
		                          const char *buf, size\_t count)\\
		\lbrace \\
		snprintf(dev->name, sizeof(dev->name), ``\%.*s'',(int)min(count, sizeof(dev->name) - 1), buf);\\
		return count;\\
		\rbrace\\
		static DEVICE\_ATTR(name, S\_IRUGO, show\_name, store\_name);\\
		\end{code}
		The top level sysfs directory looks like:\\
		\begin{itemize}
		\item block
		\item bus
		\item class
		\item dev
		\item devices
		\item firmware
		\item net
		\item fs
		\item devices
		contains a filesystem representation of the device tree. It maps
		directly to the internal kernel device tree, which is a hierarchy of
		struct device.
		\item bus
		contains flat directory layout of the various bus types in the
		kernel. Each bus's directory contains two subdirectories:\\
		devices\\
		drivers
		\item devices 
		contains a directory for each device driver that is loaded
		for devices on that particular bus (this assumes that drivers do not
		span multiple bus types).
		\end{itemize}
		By making the entry of our device in the sysfs we are able to see it in the sysfs directory under spi directory as shown in below figure:\\
		cd /sys/devices/platform/spi \\
		Using the above command we are able to see the sysfs file for SPIRIT1.

			\begin{figure}[ht]
				\centering
				\includegraphics[scale=1]{images/sysfs.png}
				\caption{entry of SPIRIT1 in sysfs}
			\end{figure}
			To read the contents of the sysfs we have to change the mode using below command: \\
			sudo chmod 666 -R fileOne
\subsection{Initialize the hardware}
After making the entry for the SPIRIT1 in sysfs we have to initialize the hardware i.e. SPIRIT1 on linux platform for that we have to make an entry of the hardware in the probe function. probe() will be called to make sure that the device exist and the functionality is fine.If device is not hot-pluggable, functionality of probe() can be put inside init() method.This will reduce driver's run time memory footprint. Probe() happens at the time of device boot or when device is connected.For a ``platform'' device the probe function is invoked when a platform device is registered and it's device name matches the name specified on the device driver. \\
To make an entry in the probe function the syntax is: \\
              err = stsp\_hw\_init(dev);\\
	      Now we have to initialize the hardware. \\
	\begin{code}
	static int stsp\_hw\_init(struct stsp\_dev *dev)\\
	\lbrace \\
	int err;\\
        u8 data;\\
       err = dev->tf->read(dev, DEVICE\_INFO0\_VERSION, 1, &data);\\
        printk(``probing the function = ravi'');\\
	static int stsp\_hw\_init(struct stsp\_dev *dev)\\
	\lbrace \\
        int err;\\
        u8 data;\\
        err = dev->tf->read(dev, DEVICE\_INFO0\_VERSION, 1, &data);\\
        printk(``probing the function = ravi'');\\
        if (err < 0)\\
        \lbrace \\
         dev\_err(dev->dev, ``error reading the version\n'');\\
         return err;\\
        \rbrace \\
        printk(``probbing = \%d'', err);\\
        if (data != DEVICE\_INFO0\_VERSION)\\
 \lbrace \\
 dev\_err(dev->dev, ``device unknown \0x\%02x-0x'', DEVICE\_INFO0\_VERSION, data);\\
  return -ENODEV;\\
        \rbrace \\
        return err;\\
	\rbrace \\
	\end{code}
After initializing the hardware and insert the modules using \\ sudo insmod spi.ko \\ and then checking the result running the below command \\ dmesg \\ we will see the entry of hardware as shown in figure below. I am getting this output because hardware is not connected to my RPI board we will see the result with the hardware connecting in the testing section. Here we have to check only whether the hardware entry is made or not in Linux. \\
			\begin{figure}[ht]
				\centering
				\includegraphics[scale=1]{images/hardware_result.png}
				\caption{Hardware initialization in Linux}
			\end{figure}
\subsection{Port the essential stuff}
After initializing the hardware now our main focus is to write the essential stuff for the SPIRIT1. Essential stuff means Register, Interrupts enablein SPIRIT1, commands required to ready the hardware and payload. For that we have to take the help from SPIRIT1 datasheet. 
\paragraph{Interrupts in SPIRIT1} \\
A handler is expected to perform any necessary acknowledgement of the parent IRQ via the correct chip specific function. In the Linux there is already the entry of Interrupts under this directory \\ \#include$<$irq.h$>$\\. 
\begin{itemize}
\item set\_irq\_chip(irq,\ chip) \\
Set the mask/unmask methods for handling this IRQ.
\item set\_irq\_handler(irq,\ handler)\\
Set the handler for this IRQ (level, edge, simple).
\item set\_irq\_chained\_handler(irq, handler)\\
Set a ``chained'' handler for this IRQ - automatically enables this IRQ.
\item set\_irq\_flags(irq, flags)\\
Set the valid/probe/noautoenable flags.
\item set\_irq\_type(irq, type)
Set active the IRQ edge(s)/level. This is also for the GPIO of the SPIRIT1. As we seen in the datasheet of the SPIRIT1 that there are four GPIO's in it. This interrupt is for the GPIO's.
set\_GPIO\_IRQ\_edge() is obsolete, and should be replaced by set\_irq\_type.
\end{itemize}

\section{Testing}
The driver job is to send the commands from the one device to another one and getting back its response. If all this happen sucessfully then that should means that the one SPIRIT1 is able to communicate with another SPIRIT1.\\
For testing the SPIRIT1 we have to do the following procedure:
\subsection{Enable the SPI in RPI2 board}
	\begin{enumerate}
		\item To enable the SPI in raspberry PI board. Run the following command.
			\textbf{sudo raspi-config}
			\begin{figure}[ht]
				\centering
				\includegraphics[scale=1.3]{images/spi.png}
				\caption{enable the SPI in RPI2 board}
			\end{figure}
		\item Select the Advanced boot option
		\item Select Enable the SPI and then select on save and exit
	\end{enumerate}
\subsubsection{Make the entry in dts}
We discused in the previous section about the .dts. Now we have to make the entry of the SPIRIT1 in the dts then we have to convert this into .dtb. 
for making the entry in the .dts we have to run the following command:\\
cd linux\\
cd arch/arm/boot/dts\\
vi bcm2709-rpi2b.dts\\
then add the following in the SPI category as shown in figure:\\
\begin{figure}[H]
	\centering
	\includegraphics[width=3in, height=2in]{images/dts.png}
	\caption{Entry in dts}
\end{figure}
\subsection{Interfacing between RPI2 and SPSGRF(SPIRIT1)}
The SPSGRF-868 and SPSGRF-915 are easy-to-use, low power sub-GHz modules based on the SPIRIT1 RF transceiver, operating respectively in the 868 MHz SRD and 915 MHz ISM bands.\\
The SPSGRF series enables wireless connectivity in electronic devices, requiring no RF experience or expertise for integration into the final product. As an FCC, IC, and CE certified solution, the SPSGRF series optimizes the time-to-market of end applications. The SPSGRF-915 is an FCC certified module (FCC ID: S9NSPSGRF) and IC certified (IC 8976C-SPSGRF), while the SPSGRF-868 is certified CE0051.
\begin{table}[ht]
	\centering
	\scalebox{1}
	{
		\begin{tabular}{|K{3cm} | K{2cm} | K{5cm}|}
		\toprule
		\rowcolor{Gray}
		\textbf{Pin name} & \textbf{RPI2 pin no.} & \textbf{SPSGRF pin no.} \\
		\hline
		MISO & 19 & 12 \\
		\hline
		MOSI & 21 & 12 \\
		\hline
		SCLK & 23 & 12 \\
		\hline
		CSn & 24 & 12 \\
		\hline
		VSS & 1 & 12 \\
		\hline
		GND & 6 & 12 \\
		\bottomrule
		\end{tabular}
	}
	\caption{RPI2 and SPIRIT1 Interfacing}
\end{table}
\begin{figure}[H]
	\centering
	\includegraphics[width=4.5in, height=3in]{images/interfacing.jpg}
	\caption{Interfacing between RPI2 and SPIRIT1}
\end{figure}
\subsection{Test using logic Analyzer}
We discussed in the previous section about the logic analyzer and how it works. Now we test the SPI of SPIRIT1 using logic analyzer. It gives us an idea that the data through the SPI is going correctly or not. For that we have to connect the logic Analyzer with the SPIRIT1 board and send the data over sysfs file using command:\\
\textbf{echo FF $>$ filename}\\
Run the above command and notice the data over logic analyzer. It gives:
After the data through the SPI is flowing correctly. Now we have to send the commands for the SPIRIT1 to become ready. For that we send the command 0x03 over SPI after that SPIRIT1 become ready to accept the data. 
\begin{figure}[H]
	\centering
	\includegraphics[width=4.5in, height=2.5in]{images/raspberryoutput.png}
	\caption{Raspberry PI output on logic Analyzer}
\end{figure}
\subsection{Test the hardware}
When the SPIRIT1 become ready to accept the data. Now for the hardware verification we have to read the version info and version number of the SPIRIT1 to verify that whether our hardware is recognised by the Linux or not.\\
\begin{table}[ht]
	\centering
	\scalebox{0.85}
	{
	\begin{tabular}{|K{5cm} | K{2cm} | K{5cm} | K{2cm} | K{5cm}|}
	\toprule
	\rowcolor{Gray}
	\textbf{Regsiter} & \textbf{Address} & \textbf{Field name} & \textbf{Reset} & \textbf{Description} \\
	\hline
	DEVICEINFO & 0xF0 & PARTNUM & 0x01 & Device part number \\
	\hline
	DEVICEINFO & 0xF1 & VERSION & 0x30 & Device version number \\
	\bottomrule
	\end{tabular}
	}
	\caption{Hardware Register}
\end{table}
\noindent As shown in the table that for the version info and version number we have to read the value from the SPIRIT1 using the read function and that should give the value, \\
\begin{table}[ht]
	\centering
	\scalebox{0.85}
	{
	\begin{tabular}{|K{5cm} | K{5cm}|}
	\toprule
	\rowcolor{Gray}
	\textbf{Part NUMBER} & \textbf{Part VERSION} \\
	\hline
	1 & 48 \\
	\bottomrule
	\end{tabular}
	}
	\caption{Value to be read from SPIRIT1}
\end{table}




